set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
CLI="${ROOT_DIR}/cli/tswf.sh"
LOG="${ROOT_DIR}/logs/tswf.log"
TASKS_DIR="${ROOT_DIR}/config/tasks.d"
FIXTURES_DIR="${ROOT_DIR}/tests/fixtures"

fail() { echo "âŒ $*" >&2; exit 1; }
info() { echo "ðŸ§ª $*"; }

require_file() { [[ -f "$1" ]] || fail "Missing required file: $1"; }

# Grep wrapper that fails with readable context if no match
must_grep() {
  local pattern="$1"; shift
  local haystack="$1"; shift
  echo "$haystack" | grep -E -q "$pattern" || {
    echo "---- begin context ----"
    echo "$haystack"
    echo "---- end context ------"
    fail "Expected pattern not found: $pattern"
  }
}

# Extract run_id=NNN from a log line
extract_run_id() {
  local line="$1"
  echo "$line" | sed -nE 's/.*run_id=([0-9]+).*/\1/p'
}

# Extract exit=NN from a log line
extract_exit_code() {
  local line="$1"
  echo "$line" | sed -nE 's/.*exit=([0-9]+).*/\1/p'
}


require_file "$CLI"
mkdir -p "$FIXTURES_DIR" "$TASKS_DIR" "$(dirname "$LOG")"

# Count lines before to slice the log later
before_lines=0
if [[ -f "$LOG" ]]; then
  before_lines=$(wc -l < "$LOG" || echo 0)
fi


# OK task (exit 0)
OK_TASK_SCRIPT="${FIXTURES_DIR}/task_ok.sh"
cat > "$OK_TASK_SCRIPT" <<'EOS'
#!/usr/bin/env bash
echo "OK says hi"
exit 0
EOS
chmod +x "$OK_TASK_SCRIPT"

# FAIL task (non-zero exit)
FAIL_TASK_SCRIPT="${FIXTURES_DIR}/task_fail.sh"
cat > "$FAIL_TASK_SCRIPT" <<'EOS'
#!/usr/bin/env bash
echo "FAIL says bye" >&2
exit 1
EOS
chmod +x "$FAIL_TASK_SCRIPT"

# Register tasks (idempotent; will overwrite their .task and cron line)
"$CLI" task add --name task_ok   --cmd "$OK_TASK_SCRIPT"   --cron '*/5 * * * *' --desc "unit test ok"
"$CLI" task add --name task_fail --cmd "$FAIL_TASK_SCRIPT" --cron '*/5 * * * *' --desc "unit test fail"


# 1) Run OK task and assert exit code 0
set +e
"$CLI" task run --name task_ok
ok_code=$?
set -e
[[ $ok_code -eq 0 ]] || fail "Expected exit code 0 for task_ok, got $ok_code"

# 2) Run FAIL task and assert non-zero
set +e
"$CLI" task run --name task_fail
fail_code=$?
set -e
[[ $fail_code -ne 0 ]] || fail "Expected non-zero exit code for task_fail, got $fail_code"

info "Exit code checks passed (ok=$ok_code, fail=$fail_code)."


# Slice new log content generated by the two runs
total_lines=$(wc -l < "$LOG" || echo 0)
start_line=$((before_lines + 1))
new_log="$(tail -n +"$start_line" "$LOG" 2>/dev/null || true)"

# Basic structure check (timestamp / level / component)
must_grep '^timestamp=[0-9T:+-]+ level=(INFO|WARN|ERROR) component=[a-z]+' "$new_log"

# Ensure we have start/finish pairs for both tasks
must_grep 'component=task .*task=task_ok .*event=start' "$new_log"
must_grep 'component=task .*task=task_ok .*event=finish .*exit=[0-9]+' "$new_log"
must_grep 'component=task .*task=task_fail .*event=start' "$new_log"
must_grep 'component=task .*task=task_fail .*event=finish .*exit=[0-9]+' "$new_log"

# Extract the specific lines we care about
start_ok_line="$(echo "$new_log" | grep -E 'component=task .*task=task_ok .*event=start'   | tail -n1)"
finish_ok_line="$(echo "$new_log" | grep -E 'component=task .*task=task_ok .*event=finish' | tail -n1)"
start_fail_line="$(echo "$new_log" | grep -E 'component=task .*task=task_fail .*event=start'   | tail -n1)"
finish_fail_line="$(echo "$new_log" | grep -E 'component=task .*task=task_fail .*event=finish' | tail -n1)"

ok_run_id="$(extract_run_id "$start_ok_line")"
fail_run_id="$(extract_run_id "$start_fail_line")"
ok_exit_logged="$(extract_exit_code "$finish_ok_line")"
fail_exit_logged="$(extract_exit_code "$finish_fail_line")"

[[ -n "$ok_run_id"   && "$ok_run_id"   =~ ^[0-9]+$ ]]   || fail "Invalid run_id for task_ok start."
[[ -n "$fail_run_id" && "$fail_run_id" =~ ^[0-9]+$ ]]   || fail "Invalid run_id for task_fail start."

# Ensure run_id consistency start <-> finish
echo "$finish_ok_line"   | grep -q "run_id=${ok_run_id}"   || fail "Mismatched run_id for task_ok finish."
echo "$finish_fail_line" | grep -q "run_id=${fail_run_id}" || fail "Mismatched run_id for task_fail finish."

# Ensure logged exit semantics: 0 for success, non-zero for failure
[[ "$ok_exit_logged" == "0" ]]       || fail "Expected logged exit=0 for task_ok, got $ok_exit_logged."
[[ "$fail_exit_logged" != "0" ]]     || fail "Expected non-zero logged exit for task_fail, got $fail_exit_logged."

# Ensure levels: INFO on success, ERROR on failure
echo "$finish_ok_line"   | grep -q 'level=INFO'  || fail "Expected INFO level on task_ok finish."
echo "$finish_fail_line" | grep -q 'level=ERROR' || fail "Expected ERROR level on task_fail finish."

info "Structured logging checks passed."

echo "All unit tests passed: Exit Codes & Logging"